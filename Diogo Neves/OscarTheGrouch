using System;
using System.Collections.Generic;
using System.Linq;
using mob_ai_csharp.multipaint;
using Newtonsoft.Json;

namespace mob_ai_csharp
{
    public class Bot : IBot
    {
        public List<string> ActionTypes = new List<string>() { "shoot", "walk" };

        public List<List<int>> ActionDirections = new List<List<int>>()
        {
            new List<int>{ -1 , -1 }, //UPLEFT
            new List<int>{  0 , -1 },  //LEFT
            new List<int>{  1 , -1 },  //DOWNLEFT
            new List<int>{ -1 , 0  },  //UP
            new List<int>{  1 , 0  },   //DOWN
            new List<int>{ -1 , 1  },  //UPRIGHT
            new List<int>{  0 , 1  },   //RIGHT
            new List<int>{  1 , 1  },   //DOWNRIGHT
        };

        private string PlayerId;

        public Random R;

        private Point myCurrentPos;

        private static void Main(string[] args)
        {
            Runner.Run(new Bot());
        }

        public void SetPlayerId(string playerId)
        {
            this.PlayerId = playerId;
            this.R = new Random();
        }

        public Move NextMove(Board boardState)
        {
            myCurrentPos = new Point(boardState.player_positions[this.PlayerId][1], boardState.player_positions[this.PlayerId][0]);
            Console.Error.WriteLine($"My old position-> ({myCurrentPos.X}, {myCurrentPos.Y})");

            //Depth stuff
            //Get a Move
            var move = new Move();
            var dic = new Dictionary<List<int>, int>();

            ActionDirections.ForEach(x => dic.Add(x, 0));

            move = GetNextAttack(boardState, myCurrentPos);

            if (move != null)
            {
                MapList2Move(move.Direction);
                return move;
            }

            move = GetNewMove(boardState, myCurrentPos, dic, 1);

            if (move == null)
            {
                move = BackUpMove(myCurrentPos, boardState);
            }

            MapList2Move(move.Direction);

            return move;
        }

        private Move BackUpMove(Point myCurrentPos, Board boardState)
        {
            var dic = new Dictionary<List<int>, double>();

            var opponentID = boardState.player_positions.FirstOrDefault(x => x.Key != PlayerId).Key;

            var opponentPos = boardState.player_positions[opponentID];

            for (int i = 0; i < ActionDirections.Count; i++)
            {
                var newPoint = ExecuteWalkMove(ActionDirections[i], myCurrentPos);

                var distance = Math.Sqrt(Math.Pow(newPoint.X - opponentPos[1], 2) + Math.Pow(newPoint.Y - opponentPos[0], 2));

                dic.Add(ActionDirections[i], distance);
            }

            var move = new Move();
            move.Type = ActionTypes[1];
            move.Direction = dic.OrderBy(x => x.Value).FirstOrDefault().Key;

            return move;
        }

        private Move GetNextAttack(Board boardState, Point myCurrentPos)
        {
            var dic = new Dictionary<List<int>, int>();
            var optimalAttack = new Move() { Direction = ActionDirections[0], Type = ActionTypes[0] }; // Random Move vvery not hardcoded;

            for (int i = 0; i < ActionDirections.Count; i++)
            {
                var newPoint = ExecuteWalkMove(ActionDirections[i], myCurrentPos);

                var attackDirection = new List<int> { -ActionDirections[i][0], -ActionDirections[i][1] };
                var attackPoint = ExecuteWalkMove(attackDirection, myCurrentPos);

                var count = 0;

                while (!OutOfBounds(newPoint, boardState) && !OutOfBounds(attackPoint, boardState) && boardState.colors[newPoint.Y][newPoint.X] == PlayerId)
                {
                    if (boardState.colors[attackPoint.Y][attackPoint.X] != PlayerId)
                    {
                        count++;
                    }

                    newPoint = ExecuteWalkMove(ActionDirections[i], newPoint);
                    attackPoint = ExecuteWalkMove(attackDirection, attackPoint);
                }

                dic[attackDirection] = count;
            }

            var nSt = dic.Where(x => x.Value >= 2).OrderByDescending(x => x.Value).FirstOrDefault();

            if (nSt.Key == null)
                return null;

            optimalAttack.Direction = nSt.Key;
            return optimalAttack;
        }

        private Move GetNewMove(Board boardState, Point myCurrentPos, Dictionary<List<int>, int> dic, int i)
        {
            var optimalMove = new Move() { Direction = ActionDirections[0], Type = ActionTypes[1] }; // Random Move vvery not hardcoded;

            if (i <= 0)
            {
                optimalMove.Direction = dic.OrderByDescending(x => x.Value).FirstOrDefault().Key;

                return optimalMove;
            }

            for (int j = 0; j < ActionDirections.Count; j++)
            {
                var newPosition = ExecuteWalkMove(ActionDirections[j], myCurrentPos);

                if (OutOfBounds(newPosition, boardState))
                    continue;

                if (boardState.colors[newPosition.Y][newPosition.X] != PlayerId)
                {
                    dic[ActionDirections[j]]++;
                    boardState.colors[newPosition.Y][newPosition.X] = PlayerId;
                    var newMove = GetNewMove(boardState, newPosition, dic, --i);
                    return newMove;
                }
            }

            var nSt = dic.Where(x => x.Value > 0).OrderByDescending(x => x.Value).FirstOrDefault();

            if (nSt.Key == null)
            {
                return null;
            }

            optimalMove.Direction = nSt.Key;
            return optimalMove;
        }

        private bool OutOfBounds(Point point, Board boardState)
        {
            return point.X < 0 || point.X >= boardState.width || point.Y < 0 || point.Y >= boardState.height;
        }

        public Point ExecuteWalkMove(List<int> move, Point cP) => new Point(cP.X + move[1], cP.Y + move[0]);

        public void MapList2Move(List<int> move)
        {
            if (move[0] == 1)
            {
                if (move[1] == 1)
                {
                    Console.Error.WriteLine("DOWN RIGHT");
                }
                else if (move[1] == 0)
                {
                    Console.Error.WriteLine("DOWN");
                }
                else
                {
                    Console.Error.WriteLine("DOWN LEFT");
                }
            }
            else if (move[0] == 0)
            {
                if (move[1] == 1)
                {
                    Console.Error.WriteLine("RIGHT");
                }
                else if (move[1] == 0)
                {
                    Console.Error.WriteLine("NO ACTION");
                }
                else
                {
                    Console.Error.WriteLine("LEFT");
                }
            }
            else if (move[0] == -1)
            {
                if (move[1] == 1)
                {
                    Console.Error.WriteLine("UP RIGHT");
                }
                else if (move[1] == 0)
                {
                    Console.Error.WriteLine("UP");
                }
                else
                {
                    Console.Error.WriteLine("UP LEFT");
                }
            }
        }
    }

    public class Point
    {
        public int X { get; set; }
        public int Y { get; set; }

        public Point()
        {
        }

        public Point(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }
    }
}
