"use strict";

const multipaint = require("multipaint");

const choice = (array) => array[Math.floor(Math.random() * array.length)];

const getDirections = () => {

  const a = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

const calculateValueBasedOnNearby = (player_id, state, [row,column]) => {
  
  
  let value =0;
  const arrayDirections = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  arrayDirections.forEach( dir => {
    const nextRow = row+dir[0];
    const nextCol = column + dir[1];
    if(nextRow <0 || nextRow >= state.width || nextCol < 0 || nextCol >= state.height){ 
    }else if(state.colors[nextRow][nextCol] != player_id ){
      value += 1;
    }
  });
  return value != 0 ? value /10 : 0;
};



const calculateCellWalkValue = (name, player_id, state, pos) => {
  let value = 0;
  switch(name){
    case player_id:
      value = calculateValueBasedOnNearby(player_id, state, pos);
      break;
    case null:
      value = 1;
      break;
    default:
      value=2;
      break;
  }
  return value;
}
const calculateCellShootValue = (row, column, colors, player_id, dir, height, width) => {
  let value = 0;
  let sameColorBehind = 0;
  let inc=0;
  let loop=true;
  while(loop){
    inc++;
    const nextRow = row - 1*dir[0] - inc*dir[0]; 
    const nextCol = column - 1*dir[1] - inc*dir[1]; 
    if(nextRow <0 || nextRow >= width || nextCol < 0 || nextCol >= height){
      loop=false;
    }else {
      if(colors[nextRow][nextCol] == player_id){
        value++;
      }else{
        loop=false;
      }

    }
  }
  inc=-1;
  let sameColorFront= 0;
  loop=true;
  while(loop){
    inc++;
    const nextRow = row + inc*dir[0]; 
    const nextCol = column + inc*dir[1]; 
    if(nextRow <0 || nextRow >= width || nextCol < 0 || nextCol >= height){
      loop=false;
    }else {
      if(colors[nextRow][nextCol] == player_id){
        value--;
      }else{
        loop=false;
      }

    }
  }

  

  return value;
}

const calculateShootValue = (colors, [prow, pcolumn],height, width,player_id ) => {
  let maxPoints=-1;
  let chosenDirection=[0,0];

  const arrayDirections = getDirections();
  arrayDirections.forEach( dir => {
    let inc = 0;
    let value=0;

    while(true){
      inc++;
      const nextRow = prow + inc*dir[0]; 
      const nextCol = pcolumn + inc*dir[1]; 
      if(nextRow <0 || nextRow >= width || nextCol < 0 || nextCol >= height){
        break;
      }else {
        if(colors[nextRow][nextCol] == player_id){
          value++;
        }else{
          break;
        }

      }
    }
    inc=0;
    let dem=0;
    while(true){
      inc++;
      const nextRow = prow - inc*dir[0]; 
      const nextCol = pcolumn - inc*dir[1]; 
      if(nextRow <0 || nextRow >= width || nextCol < 0 || nextCol >= height){
        break;
      }else {
        if(colors[nextRow][nextCol] != player_id){
          dem++;
        }else{
          break;
        }

      }
    }
    value = dem < value ? dem : value; 
    if(value > maxPoints){
      maxPoints = value;
      chosenDirection = dir;
    }
  });
  return [maxPoints,chosenDirection];
}


const chooseAction = (board, [pcolumn, prow], height, width,player_id,colors,player_positions) => {
  let maxPoints=-1;
  let chosenDirection=[0,0];
  let chosenAction='walk';

  const arrayDirections = getDirections();
  arrayDirections.forEach( dir => {
    const column =  pcolumn + dir[0];
    const row =  prow + dir[1];
    if(column >= 0 && column < height && row >= 0 && row < width){
    
      const walkPoints = board[column][row];
      if(walkPoints > maxPoints) {
        maxPoints = walkPoints;
        chosenDirection = dir;
        chosenAction = 'walk';
      }
      

    }
  });
  const [shootPoints,dir] = calculateShootValue(colors,player_positions[player_id],height,width);
  if(shootPoints >= maxPoints) {
    maxPoints = shootPoints;
    chosenDirection = dir;
    chosenAction = 'shoot';
  }
 return [chosenAction, chosenDirection]; 
}

class Megabot2000 {
  constructor(player_id) {
    this.player_id = player_id;
  }

  next_move(state) {
    let board = state.colors.map((line,row) => line.map( (cell, column) => (calculateCellWalkValue(cell, this.player_id,state,[row,column]))));
    const otherPlayers = Object.keys(state.player_positions).map( key => key != this.player_id ? state.player_positions[key] : null).filter( o=> o );
    otherPlayers.forEach(o => board[o[0]][o[1]] = -1);
    
    const [type, direction] = chooseAction(board, state.player_positions[this.player_id],state.height,state.width,this.player_id,state.colors,state.player_positions);
    return {
      type,
      direction,
    };
  }
}

multipaint.run(Megabot2000);